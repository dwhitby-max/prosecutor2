import { PDFParse } from 'pdf-parse';
import { PNG } from 'pngjs';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

export type PdfTextResult = { text: string; pageCount: number | null };

export async function extractPdfText(pdfBytes: Buffer): Promise<PdfTextResult> {
  try {
    const pdfParse = new PDFParse({ data: new Uint8Array(pdfBytes) });
    const result = await pdfParse.getText();
    await pdfParse.destroy();
    return { 
      text: result.text ?? '', 
      pageCount: result.pages?.length || null 
    };
  } catch (err) {
    console.error('PDF text extraction failed:', err);
    return { text: '', pageCount: null };
  }
}

export type ExtractedImage = {
  index: number;
  page: number | null;
  mimeType: 'image/png' | 'image/jpeg';
  bytes: Buffer;
};

export type PdfImagesResult = { images: ExtractedImage[] };

export async function extractPdfImages(pdfPath: string, outDir: string): Promise<string[]> {
  try {
    fs.mkdirSync(outDir, { recursive: true });
    cp.execSync(`pdfimages -all "${pdfPath}" "${outDir}/img"`);
    return fs.readdirSync(outDir).map(f => path.join(outDir, f));
  } catch {
    return [];
  }
}

// Convert PDF bytes to PNG images of each page using pdf2pic alternative
// Since we can't easily render PDF pages without complex dependencies,
// we'll create a simple representation for Gemini to analyze
export async function convertPdfToImages(pdfBytes: Buffer, maxPages: number = 10): Promise<ExtractedImage[]> {
  // For scanned PDFs, we need to send the raw PDF data to Gemini
  // Gemini can process PDF documents directly via inline data
  // Create a single "image" entry that represents the entire PDF
  const result = await extractPdfText(pdfBytes);
  const pageCount = result.pageCount || 1;
  
  // Return empty if we got readable text (no OCR needed)
  const readableChars = result.text.replace(/[^a-zA-Z0-9\s.,!?;:'"()-]/g, '').length;
  const isReadable = result.text.length > 100 && (readableChars / result.text.length) > 0.5;
  
  if (isReadable) {
    return [];
  }
  
  // For scanned PDFs, we'll process the PDF directly with Gemini
  // Return a marker that tells the caller to use PDF-based OCR
  return [{
    index: 0,
    page: null, // null indicates entire document
    mimeType: 'image/png' as const, // Will be overridden with application/pdf
    bytes: pdfBytes, // Pass the raw PDF bytes
  }];
}

// Check if extracted text appears to be from a scanned document
export function isScannedDocument(text: string): boolean {
  if (!text || text.trim().length < 120) return true;

  if (/$begin:math:text$cid:\\d+\$end:math:text$/i.test(text)) return true;

  const cleaned = text
    .replace(/\u0000/g, "")
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, "")
    .trim();

  if (cleaned.length < 120) return true;

  const letters = (cleaned.match(/[A-Za-z]/g) || []).length;
  const spaces = (cleaned.match(/\s/g) || []).length;
  const symbols = cleaned.length - letters - spaces;

  if (symbols / cleaned.length > 0.35) return true;
  if (letters / cleaned.length < 0.25) return true;

  return false;
}
